---
title: "MoT Road Safety Project"
author: "Kathlyn Ycong"
date: "03/08/2021"
output: html_document
---



`Project Aim/Goal`
MoT are looking to adapt traficalmr utilities and methodologies for New Zealand 
using open data to understand road safety outcomes

`Project Description`
Adapting UK's trafficalmr to the New Zealand context and enable policy.traffic 
calming intervention analyses.

This project involves data processing with various data such as geospatial 
datasets, APIs and census datasets.

The policy analysis will use the developed data foundations to estimate the 
casualty rate per billion kilometres for walking and cycling during journey 
to work commutes.


`Project Outcomes`
- R functions for processing CAS, census journet to work and, transport relevant 
openstreetmap data using trafficalmr as a guide.
- Estimating causalty rates per billion kilometers for cycling and walking


### Data Inputs
1. Crash Analysis System (CAS) data from NZTA
2. open data from NZTA
3. OpenStreetMap for geospatial data on transport infrastructure
4. Stats NZ census journey to work data


####Crash data
https://opendata-nzta.opendata.arcgis.com/datasets/8d684f1841fa4dbea6afaefc8a1ba0fc_0

- extracted from the TransportAgency Crash Analysis System(CAS). CAS records all traffic crashes as reported to the Transport Agency by the NZ Police. Not all crashes are reported to the NZ Police. the level of reporting increases with the severity of the crash. Due to the nature of non-fatal crashes it is believed that these are under-reported. CAS covers crashes on all New Zealand roadways or places where the public have legal access with motor vehicle.

####Open Street Map
https://www.openstreetmap.org/

- A map of the world, createdfor free to use under an open license


####Stats NZ census journey to work data
- The 2018 Census commuter view dataset contains the employed census usually resident population count aged 15 years and over by statistical area 2 for the main means of travel to work variable from the 2018 census.
The geography corresponds to 2018 boundaries

- This 2018 Census commuter view dataset is displayed by statistical area 2 geography and contains from-to (journey) information on an individual's usual residence and workplace address by main means to travel of work

Workplace address definition
- coded from information supplied by respondents about their workplaces. Where respondents do not supply sufficient information, their responses are coded to 'no further defined'. The 2018 Census commuter view datasets excludes these 'not further defined' areas, as such the sum of the counts for each region in this dataset may not be equal to the total employed census usually resident population count aged 15 years and over for that region. 


# Data Analysis


### NZTA Crash data


As noted by Shriv the columns X and Y in CAS data is a GeometryTrype Type. A spatial dataset and the crs is 2193 (usually used 4326). 2193 is a standard specifically for NZ https://epsg.io/2193.

The CAS data consists of the count of object and vehicle type associate to each crash (per row). 

Is there a need to check the interaction other attributes in the data such as weather using regression?

Crash data consists of crashes from 2000 to 2021.

```{r}
## Loading the data

if (!file.exists("Data/Crash_Analysis_System_(CAS)_data.rds")) {
  cas.data <- iotools::read.csv.raw("Data/Crash_Analysis_System_(CAS)_data.csv")
  saveRDS(cas.data, file="Data/Crash_Analysis_System_(CAS)_data.rds")
} else cas.data <- readRDS("Data/Crash_Analysis_System_(CAS)_data.rds")

#https://opendata-nzta.opendata.arcgis.com/datasets/8d684f1841fa4dbea6afaefc8a1ba0fc_0/explore?location=-9.962041%2C0.000000%2C2.20
names(cas.data)[1] = "X"

#size - 760k rows and 72 columns
dim(cas.data)

#preview the data
head(cas.data, 2)

#check the data types in the data
str(cas.data)

#vehicle columns
cas.vehicle <- c('bicycle', 
'bus',
'carStationWagon',
'moped',
'motorcycle',
'otherVehicleType',
'schoolBus',
'suv',
'taxi',
'train',
'truck',
'unknownVehicleType',
'vanOrUtility',
'vehicle')

hist(rowSums(cas.data[cas.vehicle], na.rm = TRUE), main = "Histogram of number of vehicles included in the crash")

barplot(colSums(cas.data[cas.vehicle], na.rm = TRUE), las=2)
colSums(cas.data[cas.vehicle], na.rm = TRUE)

```


```{r}

#plotting the number of crashes
plot(table(cas.data$crashYear), col = 4, ty = 'o', ylab = "number of crashes", main = "The count of crashes per year")

max_val <- max(table(cas.data$crashYear))

#Year with the highest crashes
table(cas.data$crashYear)[table(cas.data$crashYear) == max_val]

```
###STATS NZ Journey to work data

```{r}

#load journey to work data
journey.to.work <-  read.csv("Data/2018-census-main-means-of-travel-to-work-by-statistical-a.csv")

#size
dim(journey.to.work)

#columns
names(journey.to.work)

#columns and data type
str(journey.to.work)

```
```{r}

#proportion of people that works the same area
journey.to.work$same.area.boolean <- journey.to.work["SA2_code_usual_residence_address"] == journey.to.work["SA2_code_workplace_address"]

same.area.df <-  aggregate(journey.to.work$Total, by=list(same.area=journey.to.work$same.area), FUN=sum)

barplot(height=same.area.df$x, names=c('different area', 'same area'), col="#69b3a2")


same.area.df$x[1]/sum(same.area.df$x)
same.area.df$x[2]/sum(same.area.df$x)

```

```{r}

journey.to.work

#replacing -999 with 0
journey.to.work[journey.to.work == "-999"] <- 0

op <- par(mar = c(18,4,2,1) + 0.1)
barplot(colSums(journey.to.work[, 9:18]), las = 2)
par(op)

colSums(journey.to.work[, 9:18])
```
### joining statistical area data with journey to work data

```{r}

##loading the data
sa2.centroid.inside <-  read.csv("Data/statistical-area-2-2018-centroid-inside.csv")

names(sa2.centroid.inside)

##joining long and lat data from 'sa2 centroid inside' data with journey to work data

library(dplyr)

sa2.centroid.inside[c("SA22018_V1_00", "LATITUDE", "LONGITUDE")]

## joining coordinates (geocode) of usual residence 
df <- journey.to.work %>% 
  left_join(sa2.centroid.inside[c("SA22018_V1_00", "LATITUDE", "LONGITUDE")], by = c("SA2_code_usual_residence_address" = "SA22018_V1_00")) %>% 
  rename(usual.residence.LATITUDE = LATITUDE, usual.residence.LONGITUDE = LONGITUDE)

## joining coordinates (geocode) of usual workplace 
df2 <- df %>% 
  left_join(sa2.centroid.inside[c("SA22018_V1_00", "LATITUDE", "LONGITUDE")], by = c("SA2_code_workplace_address" = "SA22018_V1_00")) %>% 
  rename(usual.work.LATITUDE = LATITUDE, usual.work.LONGITUDE = LONGITUDE)

names(df2)

dim(df2)


```
### Calculate the distance between two points

```{r}
library(geosphere)

#getting the distance between two points using Haversine formula in meters

df2$dist <- distHaversine(df2[c("usual.residence.LONGITUDE", "usual.residence.LATITUDE")], df2[c("usual.work.LONGITUDE", "usual.work.LATITUDE")])

hist(df2[df2$dist > 0, ]$dist/1e3, breaks=1000, xlim=c(0,50))

```

### Using Mapview and osm data to plot traffic calming in Auckland

Note there are different libraries to access openstreet map, either using ggmap, mapview, OpenStreetMap.

```{r}

# this function was from trafficalmr 


tc_get_osm = function(bbox = NULL, value = NULL, output = "osm_points") {
  res = osmdata::osmdata_sf(
    osmdata::add_osm_feature(
      opq = osmdata::opq(bbox = bbox),
      key = "traffic_calming",
      value = value,
      value_exact = TRUE
    )
  )
  res[[output]]
}


## function used to get traffic calming interventions from OpenStreetMap
traffic_calming_points = tc_get_osm(bbox = "Auckland New Zealand") #tc_get_osm is from osm_data

mapview::mapview(traffic_calming_points["traffic_calming"])


```

```{r}
#https://www.r-bloggers.com/2018/11/accessing-openstreetmap-data-with-r/
#https://ggplot2tutor.com/tutorials/streetmaps

#load packages
library(tidyverse)
library(osmdata)
library(sf)
library(ggmap)

#our background map
Wel_map <- get_map(getbb("Wellington New Zealand"), maptype = "toner-background")

#final map
ggmap(Wel_map)


streets <- getbb("Wellington New Zealand")%>%
  opq()%>%
  add_osm_feature(key = "highway", 
                  value = c("motorway", "primary", 
                            "secondary", "tertiary")) %>% osmdata_sf()


```


################ TESTS OR SCRATCH##############################################

```{r}


library(tidyr)
#http://www.cookbook-r.com/Manipulating_data/Converting_data_between_wide_and_long_format/

# The arguments to gather():
# - data: Data object
# - key: Name of new key column (made from names of data columns)
# - value: Name of new value column
# - ...: Names of source columns that contain values
# - factor_key: Treat the new key column as a factor (instead of character vector)
data_long <- gather(olddata_wide, condition, measurement, control:cond2, factor_key=TRUE)


```


```{r}
##Code from Simon

library(sf) 
s=st_read("../Data/statistical-area-2-2018-centroid-inside.shp") 
plot(s$LONGITUDE, s$LATITUDE, pch='.', asp=1.2) 
q=locator(2) 
plot(s$LONGITUDE, s$LATITUDE, asp=1.2, xlim=range(q$x), ylim=range(q$y), pch=19, cex=.3) 
```


### Proportion of employees where work and home are on the same locations

```{r}
##is usual residence the same area as usual workplace
barplot(table(journey.to.work.d["Ã¯..SA2_code_usual_residence_address"] == journey.to.work.d["SA2_code_workplace_address"]))

```



### Openstreet Map 

-look at using osmar
```{r}
install.packages("rJava") #required for OpenStreetMap
install.packages("OpenStreetMap")

library(OpenStreetMap)
library(ggplot2)

LAT1 = 30
LON1 = -10
LAT2 = 50
LON2 = 10

map <- openmap(c(LAT2, LON1))

```

```{r}
#https://www.r-bloggers.com/2018/11/accessing-openstreetmap-data-with-r/
#https://ggplot2tutor.com/tutorials/streetmaps

#load packages
library(tidyverse)
library(osmdata)
library(sf)
library(ggmap)

#our background map
nz_map <- get_map(getbb("New Zealand"), maptype = "toner-background")

#final map
ggmap(mad_map)


streets <- getbb("Wellington New Zealand")%>%
  opq()%>%
  add_osm_feature(key = "highway", 
                  value = c("motorway", "primary", 
                            "secondary", "tertiary")) %>% osmdata_sf()

getbb("Wellington New Zealand")

#        min       max
#x -62.34199 -62.28839
#y  46.39124  46.43357

#       min      max
#x 174.6172 174.9372
#y -41.4488 -41.1288

ggplot() +
  geom_sf(data = streets$osm_lines,
          inherit.aes = FALSE,
          color = "black",
          size = .4,
          alpha = .8) +
  coord_sf(xlim = c(174.61, 174.93 ), 
           ylim = c(-41.44, -41.12),
           expand = FALSE) 



#final map - ggmap defauls to terrain statemen
ggmap(get_map(getbb("Wellington New Zealand"), maptype = "watercolor", source = 'osm'))+
  geom_sf(data = streets$osm_lines,
          inherit.aes = FALSE,
          color = "black",
          size = .4,
          alpha = .8) +
  coord_sf(xlim = c(174.61, 174.93 ), 
           ylim = c(-41.44, -41.12),
           expand = FALSE) 


qmap("baylor university", zoom = 14, source = "osm")

HoustonMap <- qmap("houston", zoom = 14,
color = "bw", legend = "topleft")

register_google(key = "AIzaSyCosQbm1ROEgXFoT_dDqOf1XnawTS5Ik8Y")

##testing

#our background map
mad_map <- get_map(getbb("Auckland New Zealand"), maptype = "toner-background")
cinema <- osmdata_sf(q) #need to use 

#final map
ggmap(mad_map)+
  geom_sf(data = cinema$osm_points,
          inherit.aes = FALSE,
          colour = "#238443",
          fill = "#004529",
          alpha = .5,
          size = 4,
          shape = 21)+
  labs(x = "", y = "")

```


```{r}
##########################################################################

distHaversine(df2[c("usual.residence.LONGITUDE", "usual.residence.LATITUDE")][50864:50870, ], df2[c("usual.work.LONGITUDE", "usual.work.LATITUDE")][50864:50870, ])

distHaversine(c(174.7718,-41.30328), c(174.7747, -41.29102))
distHaversine(c(174.7509,-36.80752), c(174.7564, -36.85896))

#tail(df2)
#dim(df2)


distHaversine(data.matrix(df2[c("usual.residence.LONGITUDE", "usual.residence.LATITUDE")][50864:50870, ]), data.matrix(df2[c("usual.work.LONGITUDE", "usual.work.LATITUDE")][50864:50870, ]))
# [1] 11101.706  1385.928 27904.047  3278.934  7612.498 46869.955  5747.331



distHaversine( cbind(df2$usual.residence.LONGITUDE[50864:50870], df2$usual.residence.LATITUDE[50864:50870]), df2[c("usual.work.LONGITUDE", "usual.work.LATITUDE")][50864:50870, ])


(as.matrix(df2[c("usual.residence.LONGITUDE", "usual.residence.LATITUDE")][50864:50870, ]))[1]
```

```{r}

#install.packages("geosphere")
library(geosphere)

#getting the distance between two points using Haversine formula in meters

distm(c(lon1, lat1), c(lon2, lat2), fun = distHaversine)

distm(df2[c("usual.residence.LONGITUDE", "usual.residence.LATITUDE")], df2[c("usual.work.LONGITUDE", "usual.work.LATITUDE")], fun = distHaversine)

distm(df2[c("usual.residence.LONGITUDE", "usual.residence.LATITUDE")][1:5, ], df2[c("usual.work.LONGITUDE", "usual.work.LATITUDE")][1:5, ], fun = distHaversine)

(df2[c("usual.residence.LONGITUDE", "usual.residence.LATITUDE")])
class(df2)
xy <- rbind(c(0,0),c(90,90),c(10,10),c(-120,-45))
distm(xy)
xy2 <- rbind(c(0,0),c(10,-10))
distm(xy, xy2)

get_geo_distance = function(long1, lat1, long2, lat2) {
  loadNamespace("purrr")
  loadNamespace("geosphere")
  longlat1 = purrr::map2(long1, lat1, function(x,y) c(x,y))
  longlat2 = purrr::map2(long2, lat2, function(x,y) c(x,y))
  distance_list = purrr::map2(longlat1, longlat2, function(x,y) geosphere::distHaversine(x, y))
  distance_list
    # This will return in meter as same way as distHaversine function. 
  }

test <- get_geo_distance(df2$usual.residence.LONGITUDE, df2$usual.residence.LATITUDE, df2$usual.work.LONGITUDE,  df2$usual.work.LATITUDE)

df2[c("usual.residence.LONGITUDE", "usual.residence.LATITUDE")][1:5, ]
  
```
```{r}
install.packages("gmt")
library(gmt)

test <- geodist(df2$usual.residence.LATITUDE, df2$usual.residence.LONGITUDE, 
                df2$usual.work.LATITUDE, df2$usual.work.LONGITUDE, units="km") * 1000

df2[13, ]
df2[13, 21]


distm(c(df2[17, 21], df2[17, 20]), c(df2[17, 23], df2[17, 22]), fun = distHaversine)


test[17]

```


## plotting it

```{r}
library(sf)
library(ggplot2)

my_sf <- st_as_sf(df2, coords = c("usual.residence.LONGITUDE", "usual.residence.LATITUDE")

my_sf <- st_set_crs(my_sf, crs = 4326)

#Plot it:

ggplot(my_sf)

+ 
  geom_sf(aes(color = cluster))


library(sf)
library(ggplot2)

my_sf <- st_as_sf(df2, coords = c('LON', 'LAT')

my_sf <- st_set_crs(my_sf, crs = 4326)

#Plot it:

ggplot(my_sf) + 
  geom_sf(aes(color = cluster))
```



### testing trafficalmr app

```{r}

#remotes::install_github("saferactive/trafficalmr")

library(trafficalmr)
road_data = tc_data_osm
nrow(tc_data_osm)
str(tc_data_osm)

##preview data
head(road_data)
str(road_data)

road_data_major = trafficalmr::osm_main_roads(road_data)
nrow(road_data_major) # find the main roads
#> [1] 125
road_data_junctions = osm_get_junctions(road_data_major)
road_data_clusters = cluster_junction(road_data_junctions, dist = 30)
plot(road_data$geometry, col = "grey")
plot(road_data_clusters, add = TRUE)
#> Warning in plot.sf(road_data_clusters, add = TRUE): ignoring all but the first
#> attribute
plot(road_data_junctions, add = TRUE)
plot(road_data_major$geometry, col = "black", add = TRUE)

```
More information on OSM data - traffic calming

https://github.com/saferactive/trafficalmr/blob/master/R/tc_get_osm.R

```{r}

## tc_get_osm function
## function used to get traffic calming interventions from OpenStreetMap
traffic_calming_points = tc_get_osm(bbox = "Auckland") #tc_get_osm is from osm_data

mapview::mapview(traffic_calming_points["traffic_calming"])

?mapview

test <- traffic_calming_points["traffic_calming"]

test

class(test[[2]])

```

###Recoding data
https://saferactive.github.io/trafficalmr/

```{r}

tc_recode_vehicle_type(c("Bus long", "Motorcycle long name"))

```
```{r}
v = stats19::get_stats19(year = 2018, type = "vehicles")

str(v)

dim(v)

class(v)

v$vehicle_type_simple = tc_recode_vehicle_type(v$vehicle_type)
barplot(table(v$vehicle_type))
barplot(table(v$vehicle_type_simple))

table(v$vehicle_type_simple)

```


```{r}
## convert from NZTM projection (EPSG:2193) to lat/lon
## https://www.linz.govt.nz/data/linz-data-service/guides-and-documentation/using-lds-xyz-services-in-leaflet
loc = proj4::project(cas.data[1:2], "+proj=tmerc +lat_0=0 +lon_0=173 +k=0.9996 +x_0=1600000 +y_0=10000000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs", inv=TRUE)

```

```{r}
## install.packages("snippets",,"https://rforge.net")
par(mar=rep(0,4))
plot(loc$x, loc$y, pch='.', asp=1/cos(-40.6/180*pi), ty='n')
snippets::osmap()
points(loc$x, loc$y, pch='.')
```

```{r}
list(x = c(174.149667174548, 175.383632470626), y = c(-36.554874067828, 
-36.991016113938))
par(mar=rep(0,4))
plot(loc$x, loc$y, pch='.', asp=1/cos(-40.6/180*pi), ty='n', xlim=range(q$x), ylim=range(q$y))
snippets::osmap()
points(loc$x, loc$y, pch='.')
```

```{r}
akl = loc$x > range(q$x)[1] & loc$x < range(q$x)[2] & loc$y > range(q$y)[1] & loc$y < range(q$y)[2] & cas.data$crashYear %in% 2016:2019
akl[is.na(akl)] = FALSE

sum(akl)
mean(akl)
```

```{r}
par(mar=rep(0,4))
g = aggregate(df2$Total, list(lon=df2$usual.residence.LONGITUDE,lat=df2$usual.residence.LATITUDE), sum)
plot(0, 0, pch='.', xlim=range(q$x), ylim=range(q$y), asp=1/cos(-40.6/180*pi), ty='n')
snippets::osmap(cache.dir = "/tmp")
points(g$lon, g$lat,pch=19,cex=sqrt(g$x/max(g$x))*1.2,col="#00000080")
```

```{r}
par(mar=rep(0,4))
g2 = aggregate(df2$Total, list(lon=df2$usual.work.LONGITUDE,lat=df2$usual.work.LATITUDE), sum)
plot(0, 0, pch='.', xlim=range(q$x), ylim=range(q$y), asp=1/cos(-40.6/180*pi), ty='n')
snippets::osmap(cache.dir = "/tmp")
points(g$lon, g$lat,pch=19,cex=sqrt(g$x/max(g$x))*1.2,col="#ff000040")
points(g2$lon, g2$lat,pch=19,cex=sqrt(g2$x/max(g2$x))*1.5,col="#0000ff80")
```
